import tkinter as tk
from tkinter import ttk, messagebox
from collections import defaultdict
import math

class MaquinaApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Máquina de estado finito")

        # Canvas con scroll general
        self.main_canvas = tk.Canvas(root)
        self.main_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        vscroll = ttk.Scrollbar(root, orient=tk.VERTICAL, command=self.main_canvas.yview)
        hscroll = ttk.Scrollbar(root, orient=tk.HORIZONTAL, command=self.main_canvas.xview)
        self.main_canvas.configure(yscrollcommand=vscroll.set, xscrollcommand=hscroll.set)

        vscroll.pack(side=tk.RIGHT, fill=tk.Y)
        hscroll.pack(side=tk.BOTTOM, fill=tk.X)

        self.inner_frame = ttk.Frame(self.main_canvas)
        self.main_canvas.create_window((0, 0), window=self.inner_frame, anchor="nw")
        self.inner_frame.bind("<Configure>", lambda e: self.main_canvas.configure(scrollregion=self.main_canvas.bbox("all")))

        # Variables
        self.states = []
        self.input_alphabet = []
        self.output_alphabet = []
        self.initial_state = ""
        self.transitions = defaultdict(dict)
        self.current_state = None

        # Crear interfaz
        self.create_input_frame()
        self.create_output_frame()
        self.create_simulation_frame()

    def create_input_frame(self):
        frame = ttk.LabelFrame(self.inner_frame, text="Definir Máquina", padding=10)
        frame.pack(fill=tk.X, padx=10, pady=5)

        ttk.Label(frame, text="Estados (coma):").grid(row=0, column=0)
        self.states_entry = ttk.Entry(frame, width=40)
        self.states_entry.grid(row=0, column=1)

        ttk.Label(frame, text="Alfabeto entrada:").grid(row=1, column=0)
        self.input_alphabet_entry = ttk.Entry(frame, width=40)
        self.input_alphabet_entry.grid(row=1, column=1)

        ttk.Label(frame, text="Alfabeto salida:").grid(row=2, column=0)
        self.output_alphabet_entry = ttk.Entry(frame, width=40)
        self.output_alphabet_entry.grid(row=2, column=1)

        ttk.Label(frame, text="Estado inicial:").grid(row=3, column=0)
        self.initial_state_entry = ttk.Entry(frame, width=40)
        self.initial_state_entry.grid(row=3, column=1)

        ttk.Button(frame, text="Agregar Transiciones", command=self.add_transitions).grid(row=4, column=0, columnspan=2, pady=5)
        ttk.Button(frame, text="Generar Máquina", command=self.generate_machine).grid(row=5, column=0, columnspan=2)

    def create_output_frame(self):
        frame = ttk.LabelFrame(self.inner_frame, text="Resultados", padding=10)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        self.notebook = ttk.Notebook(frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)

        # Matriz
        self.matrix_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.matrix_tab, text="Matriz")

        self.matrix_text = tk.Text(self.matrix_tab, wrap=tk.NONE)
        self.matrix_text.pack(fill=tk.BOTH, expand=True)

        # Diagrama
        self.diagram_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.diagram_tab, text="Diagrama")

        self.canvas = tk.Canvas(self.diagram_tab, bg='white', width=1000, height=700, scrollregion=(0, 0, 1500, 1500))
        self.canvas.pack(fill=tk.BOTH, expand=True)

    def create_simulation_frame(self):
        frame = ttk.LabelFrame(self.inner_frame, text="Simulación", padding=10)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        ttk.Label(frame, text="Cadena de entrada:").grid(row=0, column=0)
        self.input_string_entry = ttk.Entry(frame, width=50)
        self.input_string_entry.grid(row=0, column=1)

        ttk.Button(frame, text="Procesar Cadena", command=self.process_input_string).grid(row=1, column=0, columnspan=2, pady=5)

        self.simulation_output = tk.Text(frame, height=10, wrap=tk.WORD)
        self.simulation_output.grid(row=2, column=0, columnspan=2, sticky=tk.EW)

        ttk.Label(frame, text="Estado actual:").grid(row=3, column=0)
        self.current_state_label = ttk.Label(frame, text="No definido")
        self.current_state_label.grid(row=3, column=1, sticky=tk.W)

        ttk.Button(frame, text="Resetear Máquina", command=self.reset_machine).grid(row=4, column=0, columnspan=2, pady=5)

    def add_transitions(self):
        states = [s.strip() for s in self.states_entry.get().split(',') if s.strip()]
        inputs = [s.strip() for s in self.input_alphabet_entry.get().split(',') if s.strip()]
        outputs = [s.strip() for s in self.output_alphabet_entry.get().split(',') if s.strip()]

        if not states or not inputs or not outputs:
            messagebox.showerror("Error", "Debe ingresar estados y alfabetos.")
            return

        win = tk.Toplevel(self.root)
        win.title("Agregar Transición")

        ttk.Label(win, text="Origen:").grid(row=0, column=0)
        state_cb = ttk.Combobox(win, values=states)
        state_cb.grid(row=0, column=1)
        state_cb.current(0)

        ttk.Label(win, text="Entrada:").grid(row=1, column=0)
        input_cb = ttk.Combobox(win, values=inputs)
        input_cb.grid(row=1, column=1)
        input_cb.current(0)

        ttk.Label(win, text="Destino:").grid(row=2, column=0)
        dest_cb = ttk.Combobox(win, values=states)
        dest_cb.grid(row=2, column=1)
        dest_cb.current(0)

        ttk.Label(win, text="Salida:").grid(row=3, column=0)
        out_cb = ttk.Combobox(win, values=outputs)
        out_cb.grid(row=3, column=1)
        out_cb.current(0)

        def save():
            self.transitions[state_cb.get()][input_cb.get()] = (dest_cb.get(), out_cb.get())
            messagebox.showinfo("OK", "Transición agregada.")
            win.destroy()

        ttk.Button(win, text="Guardar", command=save).grid(row=4, column=0, columnspan=2)

    def generate_machine(self):
        try:
            self.states = [s.strip() for s in self.states_entry.get().split(',')]
            self.input_alphabet = [s.strip() for s in self.input_alphabet_entry.get().split(',')]
            self.output_alphabet = [s.strip() for s in self.output_alphabet_entry.get().split(',')]
            self.initial_state = self.initial_state_entry.get().strip()

            if self.initial_state not in self.states:
                raise ValueError("El estado inicial no es válido.")

            self.current_state = self.initial_state
            self.current_state_label.config(text=self.initial_state)

            self.generate_transition_matrix()
            self.draw_state_diagram()
            self.simulation_output.delete(1.0, tk.END)

        except Exception as e:
            messagebox.showerror("Error", str(e))

    def generate_transition_matrix(self):
        matrix = "Estado\t" + "\t".join(self.input_alphabet) + "\n"
        for s in self.states:
            row = s
            if s == self.initial_state:
                row += " (inicio)"
            for a in self.input_alphabet:
                t = self.transitions.get(s, {}).get(a, ("-", "-"))
                row += f"\t{t[0]},{t[1]}"
            matrix += row + "\n"
        self.matrix_text.delete(1.0, tk.END)
        self.matrix_text.insert(tk.END, matrix)

    def draw_state_diagram(self):
        self.canvas.delete("all")
        r = 30  # Radio de los círculos de estado
        pos = {}  # Diccionario para guardar posiciones

        # Ajuste clave: Cambiamos las coordenadas del centro (cy) para subir el diagrama
        cx, cy = 600, 300  # Originalmente cy=600, ahora cy=300 para subirlo

        radius = min(250, 200 + len(self.states) * 20)  # Radio del círculo de estados
        n = len(self.states)

        # Dibujar estados en círculo
        for i, s in enumerate(self.states):
            angle = 2 * math.pi * i / n
            x = cx + radius * math.cos(angle)
            y = cy + radius * math.sin(angle)
            pos[s] = (x, y)

            # Dibujar círculo del estado
            self.canvas.create_oval(x - r, y - r, x + r, y + r, outline='black', width=2)
            self.canvas.create_text(x, y, text=s, font=('Arial', 10))

            # Flecha para estado inicial
            if s == self.initial_state:
                self.canvas.create_line(x - 50, y, x - r, y, arrow=tk.LAST, width=2)

        # Dibujar transiciones
        offset_map = defaultdict(int)
        for s in self.states:
            for a, (dest, out) in self.transitions.get(s, {}).items():
                x1, y1 = pos[s]
                x2, y2 = pos[dest]

                # Transiciones reflexivas (estado a sí mismo)
                if s == dest:
                    self.canvas.create_arc(x1 - 40, y1 - 40, x1 + 40, y1 + 40,
                                           start=0, extent=300, style=tk.ARC)
                    self.canvas.create_text(x1, y1 - 50, text=f"{a}/{out}", font=('Arial', 8))
                else:
                    # Transiciones normales
                    dx, dy = x2 - x1, y2 - y1
                    dist = math.hypot(dx, dy)
                    ox, oy = -dy / dist * 20, dx / dist * 20  # Vector ortogonal

                    # Ajustar posición para evitar superposición
                    mid_x = (x1 + x2) / 2 + offset_map[(s, dest)] * ox
                    mid_y = (y1 + y2) / 2 + offset_map[(s, dest)] * oy

                    # Dibujar flecha
                    self.canvas.create_line(x1, y1, x2, y2, arrow=tk.LAST, width=1.5)
                    self.canvas.create_text(mid_x, mid_y, text=f"{a}/{out}", font=('Arial', 8))
                    offset_map[(s, dest)] += 1

        # Ajustar el área de scroll
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def process_input_string(self):
        input_str = self.input_string_entry.get().strip()
        if not input_str:
            return

        for sym in input_str:
            if sym not in self.input_alphabet:
                messagebox.showerror("Error", f"Símbolo inválido: {sym}")
                return

        state = self.current_state
        output = []
        steps = []

        try:
            for i, sym in enumerate(input_str):
                if sym not in self.transitions[state]:
                    raise ValueError(f"No hay transición para δ({state}, {sym})")
                state, out = self.transitions[state][sym]
                output.append(out)
                steps.append(f"Paso {i+1}: δ({self.current_state}, {sym}) → ({state}, {out})")
                self.current_state = state

            result = [
                "Resultados de Simulación",
                f"Longitud de entrada: {len(input_str)}",
                f"Cadena de entrada: {input_str}",
                f"Longitud de salida: {len(output)}",
                f"Cadena de salida: {''.join(output)}",
                f"Salida detallada: {' - '.join(output)}",
                f"Estado final: {state}",
                "",
                "Detalle de transiciones:",
                *steps
            ]

            self.simulation_output.delete(1.0, tk.END)
            self.simulation_output.insert(tk.END, "\n".join(result))
            self.current_state_label.config(text=self.current_state)

        except Exception as e:
            self.simulation_output.delete(1.0, tk.END)
            self.simulation_output.insert(tk.END, str(e))

    def reset_machine(self):
        self.current_state = self.initial_state
        self.current_state_label.config(text=self.initial_state)
        self.simulation_output.delete(1.0, tk.END)
        self.input_string_entry.delete(0, tk.END)


if __name__ == "__main__":
    root = tk.Tk()
    app = MaquinaApp(root)
    root.mainloop()
